<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=yes">
    <title>äº”å­æ£‹ Â· ä¿å®ˆAI (è‡ªé€‚åº”/æ— ç¦æ‰‹)</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            background: #3a6b4b;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            padding: 12px;
        }
        .game-box {
            background: #d9b382;
            padding: 20px 20px 18px;
            border-radius: 24px;
            box-shadow: 0 12px 18px rgba(0,0,0,0.4);
            border: 4px solid #aa7644;
            width: fit-content;
            max-width: 100%;
        }
        .canvas-wrapper {
            display: flex;
            justify-content: center;
            width: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: auto;
            background: #e9cba7;
            border-radius: 12px;
            box-shadow: inset 0 0 0 2px #b87e4b, 0 6px 10px rgba(0,0,0,0.3);
            cursor: pointer;
            touch-action: manipulation; /* æå‡è§¦å± */
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 14px;
            gap: 12px;
            flex-wrap: wrap;
        }
        .turn-badge {
            background: #4d3a28;
            color: #f0dbb4;
            padding: 6px 20px;
            border-radius: 40px;
            font-weight: bold;
            font-size: 1.3rem;
            box-shadow: inset 0 -2px 0 #2f2216, 0 3px 0 #2f2216;
            flex: 0 1 auto;
        }
        .black-turn { background: #2f4f4f; color: #fff; }
        .white-turn { background: #8b5a2b; color: #ffefcf; }
        button {
            background: #b88a5c;
            border: none;
            color: #202020;
            font-size: 1.2rem;
            font-weight: bold;
            padding: 6px 24px;
            border-radius: 40px;
            cursor: pointer;
            box-shadow: 0 5px 0 #6f4f2f, 0 6px 10px rgba(0,0,0,0.3);
            transition: 0.05s linear;
            border: 1px solid #e2be8e;
            flex: 0 1 auto;
        }
        button:active {
            transform: translateY(5px);
            box-shadow: 0 1px 0 #6f4f2f, 0 6px 10px rgba(0,0,0,0.2);
        }
        .message {
            background: #2a4b37;
            color: #fbeeae;
            padding: 6px 18px;
            border-radius: 30px;
            font-size: 1.1rem;
            font-weight: 500;
            text-align: center;
            flex: 1 1 auto;
            min-width: 180px;
        }
        footer {
            text-align: center;
            margin-top: 12px;
            color: #4b3722;
            font-size: 0.9rem;
            font-weight: 500;
        }
    </style>
</head>
<body>
<div class="game-box">
    <div class="canvas-wrapper">
        <canvas id="gobanCanvas" width="620" height="620"></canvas>
    </div>
    <div class="status-bar">
        <div class="turn-badge" id="turnIndicator">âš« ä½ çš„å›åˆ</div>
        <button id="restartBtn">â†º æ–°å±€</button>
    </div>
    <div class="message" id="statusMsg">é»‘æ£‹å…ˆèµ° (ä¿å®ˆAIç™½æ£‹)</div>
    <footer>AI ä¿å®ˆé£æ ¼ Â· æ— ç¦æ‰‹ Â· è‡ªé€‚åº”å±å¹•</footer>
</div>

<script>
// ===============  AI æ¥å£é…ç½®ï¼ˆå†…åµŒæ¼”ç¤ºï¼‰ ================
const AI_CONFIG = {
    endpoint: 'https://cloud.infini-ai.com/maas/v1/chat/completions',
    model: 'deepseek-v3.2',
    apiKey: 'sk-ajexsdmaexuoztvo'      // è¯·æ›¿æ¢ä¸ºæœ‰æ•ˆkey
};

// ===============  å…¨å±€å¸¸é‡ ================
const BOARD_SIZE = 15;
const LOGIC_SIZE = 620;          // ç”»å¸ƒé€»è¾‘åˆ†è¾¨ç‡ (åƒç´ )
const CELL_SIZE = 40;             // æ¯ä¸ªæ ¼å­é€»è¾‘åƒç´ 
const MARGIN = 20;

let board = [];                  // 0ç©º 1é»‘(ç©å®¶) 2ç™½(AI)
let currentPlayer = 1;           // 1:é»‘(ç©å®¶)  2:ç™½(AI)
let gameOver = false;
let aiThinking = false;

const canvas = document.getElementById('gobanCanvas');
const ctx = canvas.getContext('2d');
const turnIndicator = document.getElementById('turnIndicator');
const statusMsg = document.getElementById('statusMsg');

// ---------- åˆå§‹åŒ–æ£‹ç›˜ ----------
function initBoard() {
    board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(0));
    currentPlayer = 1;
    gameOver = false;
    aiThinking = false;
    drawBoard();
    updateUI();
    statusMsg.innerText = 'ä½ çš„å›åˆ (é»‘æ£‹)';
}

// ---------- ç®€åŒ–ç»˜åˆ¶ (æ— æ¸å˜/é˜´å½±ï¼Œçº¯è‰²æ£‹å­) ----------
function drawBoard() {
    ctx.clearRect(0, 0, LOGIC_SIZE, LOGIC_SIZE);

    // ç”»ç½‘æ ¼çº¿
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = '#6b4f30';
    for (let i = 0; i < BOARD_SIZE; i++) {
        const pos = MARGIN + i * CELL_SIZE;
        ctx.beginPath();
        ctx.moveTo(MARGIN, pos);
        ctx.lineTo(MARGIN + (BOARD_SIZE-1) * CELL_SIZE, pos);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos, MARGIN);
        ctx.lineTo(pos, MARGIN + (BOARD_SIZE-1) * CELL_SIZE);
        ctx.stroke();
    }

    // ç”»æ˜Ÿä½ (åªç”¨å°åœ†ç‚¹)
    ctx.fillStyle = '#4f3a22';
    const stars = [3, 7, 11];
    for (let r of stars) {
        for (let c of stars) {
            ctx.beginPath();
            ctx.arc(MARGIN + c * CELL_SIZE, MARGIN + r * CELL_SIZE, 4, 0, 2 * Math.PI);
            ctx.fill();
        }
    }

    // ç”»æ£‹å­ (çº¯è‰²ï¼Œæ— é˜´å½±)
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 0) continue;
            const x = MARGIN + c * CELL_SIZE;
            const y = MARGIN + r * CELL_SIZE;
            // å¤–è¾¹æ¡†è½»å¾®ç«‹ä½“æ„Ÿï¼Œä½†æ‰å¹³ä¸ºä¸»
            ctx.beginPath();
            ctx.arc(x, y, CELL_SIZE * 0.42, 0, 2 * Math.PI);
            ctx.fillStyle = board[r][c] === 1 ? '#222222' : '#f2f2f2';
            ctx.fill();
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }
}

// ---------- æ›´æ–°ç•Œé¢ ----------
function updateUI() {
    if (gameOver) return;
    if (currentPlayer === 1) {
        turnIndicator.innerText = 'âš« ä½ çš„å›åˆ';
        turnIndicator.className = 'turn-badge black-turn';
    } else {
        turnIndicator.innerText = 'âšª AI æ€è€ƒä¸­...';
        turnIndicator.className = 'turn-badge white-turn';
    }
}

// ---------- èƒœåˆ©æ£€æµ‹ (äº”å­è¿çº¿) ----------
function checkWinner(row, col, player) {
    if (board[row][col] !== player) return false;
    const dirs = [[1,0],[0,1],[1,1],[1,-1]];
    for (let [dx, dy] of dirs) {
        let cnt = 1;
        for (let s = 1; s < 5; s++) {
            const nr = row + dx * s, nc = col + dy * s;
            if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE || board[nr][nc] !== player) break;
            cnt++;
        }
        for (let s = 1; s < 5; s++) {
            const nr = row - dx * s, nc = col - dy * s;
            if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE || board[nr][nc] !== player) break;
            cnt++;
        }
        if (cnt >= 5) return true;
    }
    return false;
}

function isBoardFull() {
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 0) return false;
        }
    }
    return true;
}

function handleGameOver(winner) {
    gameOver = true;
    if (winner === 1) {
        statusMsg.innerText = 'ğŸ† ä½ èµ¢äº†ï¼';
        turnIndicator.innerText = 'âš« èƒœåˆ©';
    } else if (winner === 2) {
        statusMsg.innerText = 'ğŸ¤– AI èµ¢äº†';
        turnIndicator.innerText = 'âšª å¤±è´¥';
    } else {
        statusMsg.innerText = 'ğŸ¤ å¹³å±€';
        turnIndicator.innerText = 'âœ– æ»¡ç›˜';
    }
    drawBoard();
}

// ---------- å¤‡ç”¨è½å­ (ä¸­å¿ƒæœ€è¿‘ç©ºä½) ----------
function getFallbackMove() {
    let best = null;
    let minDist = Infinity;
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] !== 0) continue;
            const dist = Math.abs(r - 7) + Math.abs(c - 7);
            if (dist < minDist) {
                minDist = dist;
                best = [r, c];
            }
        }
    }
    return best; // ä¸€å®šå­˜åœ¨ï¼Œé™¤éæ»¡ç›˜
}

// ===============  AI è¯·æ±‚ï¼ˆä¿å®ˆç­–ç•¥æç¤ºè¯ï¼‰ ================
async function callAIApi() {
    if (gameOver || aiThinking) return;
    aiThinking = true;
    updateUI();
    statusMsg.innerText = 'AI ä¿å®ˆè®¡ç®—ä¸­...';

    // æ„å»ºå®Œæ•´æ£‹å±€æ–‡æœ¬
    let boardText = '';
    for (let r = 0; r < BOARD_SIZE; r++) {
        let line = '';
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 0) line += '.';
            else if (board[r][c] === 1) line += 'X';
            else line += 'O';
        }
        boardText += line + (r < BOARD_SIZE-1 ? '\n' : '');
    }

    // å¼ºè°ƒä¿å®ˆé£æ ¼ï¼šä¼˜å…ˆé˜²å®ˆæ´»ä¸‰/å†²å››ï¼Œå¤šè®¡ç®—å¨èƒï¼Œä¸‹æ£‹è°¨æ…
    const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªäº”å­æ£‹AIï¼Œæ‰§ç™½ï¼ˆOï¼‰ï¼Œå¯¹æ‰‹æ‰§é»‘ï¼ˆXï¼‰ã€‚æ£‹ç›˜15Ã—15ï¼Œåæ ‡ä»å·¦ä¸Š(0,0)åˆ°å³ä¸‹(14,14)ã€‚è§„åˆ™ï¼šæ— ç¦æ‰‹ï¼Œå…ˆè¿æˆäº”å­è€…èƒœã€‚

è¯·é‡‡å–**ä¿å®ˆç¨³å¥**çš„ä¸‹æ£‹é£æ ¼ï¼š
- ä¼˜å…ˆé˜²å®ˆå¯¹æ–¹çš„æ´»ä¸‰ã€å†²å››ç­‰ç›´æ¥å¨èƒï¼›
- ç§¯æåˆ›é€ è‡ªå·±çš„æ´»ä¸‰ã€å†²å››ï¼Œä½†é¿å…å†’é™©èµ°æ³•ï¼›
- å¤šè®¡ç®—åŒæ–¹æ½œåœ¨çš„è¿äº”å¯èƒ½æ€§ï¼Œç¡®ä¿æ£‹å½¢å®‰å…¨ã€‚

è¾“å‡ºæ ¼å¼ï¼šåªè¾“å‡ºä¸¤ä¸ªæ•°å­—ï¼Œåˆ—å’Œè¡Œï¼Œç”¨è‹±æ–‡é€—å·åˆ†éš”ï¼Œä¾‹å¦‚â€œ7,7â€ã€‚ä¸è¦æœ‰ä»»ä½•å…¶ä»–æ–‡å­—ã€‚`;

    const userMessage = `å½“å‰æ£‹ç›˜:\n${boardText}\nè¯·è¾“å‡ºä½ ä¸‹ä¸€æ­¥çš„è½å­åæ ‡ï¼ˆåˆ—,è¡Œï¼‰ï¼š`;

    try {
        const response = await fetch(AI_CONFIG.endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${AI_CONFIG.apiKey}`
            },
            body: JSON.stringify({
                model: AI_CONFIG.model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userMessage }
                ],
                temperature: 0.2,       // ç•¥ä½ï¼Œä¿æŒç¨³å®š
                max_tokens: 20,
                stream: false
            })
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const data = await response.json();
        const content = data.choices[0].message.content.trim();
        console.log('AIå›å¤:', content);

        // è§£æåæ ‡
        let clean = content.replace(/[()\s]/g, '');
        let parts = clean.split(',').filter(p => p.length > 0).map(p => parseInt(p, 10));
        let col, row;
        if (parts.length >= 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
            col = parts[0];
            row = parts[1];
        } else {
            const match = content.match(/(\d+)\D*(\d+)/);
            if (match) {
                col = parseInt(match[1], 10);
                row = parseInt(match[2], 10);
            } else {
                throw new Error(`æ— æ³•è§£æåæ ‡: ${content}`);
            }
        }

        // éªŒè¯èŒƒå›´
        if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
            throw new Error(`åæ ‡è¶Šç•Œ: (${row},${col})`);
        }

        // æ£€æŸ¥æ˜¯å¦ä¸ºç©º
        if (board[row][col] !== 0) {
            console.warn(`AIè¿”å›éç©ºç‚¹ (${row},${col})ï¼Œä½¿ç”¨å¤‡ç”¨`);
            const fb = getFallbackMove();
            if (fb) [row, col] = fb;
            else throw new Error('æ— ç©ºä½å¤‡ç”¨');
        }

        // è½ç™½å­
        board[row][col] = 2;
        drawBoard();

        if (checkWinner(row, col, 2)) {
            handleGameOver(2);
            aiThinking = false;
            return;
        }
        if (isBoardFull()) {
            handleGameOver(0);
            aiThinking = false;
            return;
        }

        currentPlayer = 1;
        aiThinking = false;
        updateUI();
        statusMsg.innerText = 'ä½ çš„å›åˆ (é»‘æ£‹)';
    } catch (error) {
        console.error('AIè°ƒç”¨å¤±è´¥:', error);
        statusMsg.innerText = `AIå¼‚å¸¸: é‡‡ç”¨å¤‡ç”¨è½å­`;
        // åå¤‡è½å­
        const fb = getFallbackMove();
        if (fb) {
            const [r, c] = fb;
            if (board[r][c] === 0) {
                board[r][c] = 2;
                drawBoard();
                if (checkWinner(r, c, 2)) handleGameOver(2);
                else if (isBoardFull()) handleGameOver(0);
                else {
                    currentPlayer = 1;
                    updateUI();
                    statusMsg.innerText = 'ä½ çš„å›åˆ (å¤‡ç”¨è½å­)';
                }
            } else {
                if (isBoardFull()) handleGameOver(0);
                else currentPlayer = 1;
            }
        } else {
            handleGameOver(0);
        }
        aiThinking = false;
    }
}

// ===============  ç©å®¶ç‚¹å‡» (åæ ‡è‡ªé€‚åº”) ================
function handleCanvasClick(e) {
    if (gameOver || aiThinking || currentPlayer !== 1) return;

    // è·å–canvaså®é™…æ˜¾ç¤ºå°ºå¯¸
    const rect = canvas.getBoundingClientRect();
    // è®¡ç®—ç‚¹å‡»åœ¨é€»è¾‘ç”»å¸ƒ(620x620)ä¸­çš„åæ ‡
    const scale = LOGIC_SIZE / rect.width;   // é€»è¾‘åƒç´  / æ˜¾ç¤ºcssåƒç´ 
    const mouseX = (e.clientX - rect.left) * scale;
    const mouseY = (e.clientY - rect.top) * scale;

    // è®¡ç®—æ ¼å­ç´¢å¼•
    const col = Math.round((mouseX - MARGIN) / CELL_SIZE);
    const row = Math.round((mouseY - MARGIN) / CELL_SIZE);
    if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) return;
    if (board[row][col] !== 0) return;

    // è½é»‘å­
    board[row][col] = 1;
    drawBoard();

    if (checkWinner(row, col, 1)) {
        handleGameOver(1);
        return;
    }
    if (isBoardFull()) {
        handleGameOver(0);
        return;
    }

    currentPlayer = 2;
    updateUI();
    statusMsg.innerText = 'AI æ€è€ƒä¸­ ...';
    callAIApi();
}

// é‡å¯æ¸¸æˆ
document.getElementById('restartBtn').addEventListener('click', () => {
    initBoard();
    aiThinking = false;
    gameOver = false;
    currentPlayer = 1;
    updateUI();
    statusMsg.innerText = 'ä½ çš„å›åˆ (é»‘æ£‹)';
    drawBoard();
});

canvas.addEventListener('click', handleCanvasClick);
// ç§»åŠ¨ç«¯è§¦å±æ”¯æŒ
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const fakeMouse = { clientX: touch.clientX, clientY: touch.clientY };
    handleCanvasClick(fakeMouse);
}, { passive: false });

// å¯åŠ¨
initBoard();
</script>
</body>
</html>